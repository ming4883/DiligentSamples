cbuffer Constants
{
};

Texture2D    g_IdTexture;
SamplerState g_IdTexture_sampler; // By convention, texture samplers must use the '_sampler' suffix

struct PSInput
{
    float4 Pos   : SV_POSITION;
    float2 UV    : TEX_COORD;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
#if defined(DESKTOP_GL) || defined(GL_ES)
    // Unlike other graphics API's, OpenGL has its texture coordinates origin at the bottom-left corner instead
    // of the top left. When sampling a regular texture, there is no visible difference since the texture data
    // is also uploaded starting from that lower-left corner. When sampling a framebuffer attachment, there is
    // a visible difference, though. Hence we need to flip the Y coordinate of the frame buffer attachment.
    float2 UV = float2(PSIn.UV.x, 1.0 - PSIn.UV.y);
#else
    float2 UV = PSIn.UV;
#endif

    uint4 Encoded = uint4(g_IdTexture.Sample(g_IdTexture_sampler, UV) * 255);
    uint PrimId = Encoded.r | (Encoded.g << 8) | (Encoded.b << 16) | (Encoded.a << 24);

    if (PrimId == 0xffffffff)
    {
        PSOut.Color = 1;
    }
    else
    {
        uint InstId   = (PrimId >> 16) & 0xffff;
        uint VertId   = PrimId & 0xffff;
        uint TriId    = VertId / 3;
        PSOut.Color.r = ((InstId % 4) + 1) / 4.0;
        PSOut.Color.g = ((TriId % 2) + 1) / 2.0;
        PSOut.Color.b = 0;
        PSOut.Color.a = 1;
    }
}
