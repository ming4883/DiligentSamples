#include "structures.fxh"
#include "common_func.fxh"

StructuredBuffer<CachedMeshVertex> g_CachedVertexData;

cbuffer Constants
{
    GlobalConstants g_Constants;
};

Texture2D    g_IdTexture;
SamplerState g_IdTexture_sampler; // By convention, texture samplers must use the '_sampler' suffix

Texture2D    g_Texture;
SamplerState g_Texture_sampler; // By convention, texture samplers must use the '_sampler' suffix

struct PSInput
{
    float4 Pos   : SV_POSITION;
    float2 UV    : TEX_COORD;
};

struct PSOutput
{
    float4 Color : SV_TARGET;
};

void Barycentric(float2 p, float2 a, float2 b, float2 c, out float3 uvw)
{
    float2 v0 = b - a, v1 = c - a, v2 = p - a;
    float den = v0.x * v1.y - v1.x * v0.y;
    uvw[1] = (v2.x * v1.y - v1.x * v2.y) / den;
    uvw[2] = (v0.x * v2.y - v2.x * v0.y) / den;
    uvw[0] = 1.0f - uvw[1] - uvw[2];
}

// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  PSInput  PSIn,
          out PSOutput PSOut)
{
#if defined(DESKTOP_GL) || defined(GL_ES)
    // Unlike other graphics API's, OpenGL has its texture coordinates origin at the bottom-left corner instead
    // of the top left. When sampling a regular texture, there is no visible difference since the texture data
    // is also uploaded starting from that lower-left corner. When sampling a framebuffer attachment, there is
    // a visible difference, though. Hence we need to flip the Y coordinate of the frame buffer attachment.
    float2 IdTexUV = float2(PSIn.UV.x, 1.0 - PSIn.UV.y);
#else
    float2 IdTexUV = PSIn.UV;
#endif

    uint4 Encoded = uint4(g_IdTexture.Sample(g_IdTexture_sampler, IdTexUV) * 255);
    uint PrimId = Encoded.r | (Encoded.g << 8) | (Encoded.b << 16) | (Encoded.a << 24);

    if (PrimId == 0xffffffff)
    {
        PSOut.Color = float4(0.5, 0.5, 0.5, 1.0);
    }
    else
    {
        uint InstId   = (PrimId >> 16) & 0xffff;
        uint TriId   = PrimId & 0xffff;

        uint BufferOffset = InstId * g_Constants.MeshDrawInfo.x + TriId * 3;

        CachedMeshVertex Cached[3];
        Cached[0] = g_CachedVertexData[BufferOffset];
        Cached[1] = g_CachedVertexData[BufferOffset+1];
        Cached[2] = g_CachedVertexData[BufferOffset+2];

        float2 Vert[3];
        float2 Texcoord[3];

        // unpack SvPos
        UnpackFloat(Cached[0].PosDepthNormalUV.x, Vert[0].x, Vert[0].y);
        UnpackFloat(Cached[1].PosDepthNormalUV.x, Vert[1].x, Vert[1].y);
        UnpackFloat(Cached[2].PosDepthNormalUV.x, Vert[2].x, Vert[2].y);

        UnpackFloat(Cached[0].PosDepthNormalUV.w, Texcoord[0].x, Texcoord[0].y);
        UnpackFloat(Cached[1].PosDepthNormalUV.w, Texcoord[1].x, Texcoord[1].y);
        UnpackFloat(Cached[2].PosDepthNormalUV.w, Texcoord[2].x, Texcoord[2].y);

        float2 HPos = (PSIn.Pos.xy - 0.5) * g_Constants.ScreenSizeInvSize.zw; // normalize
        HPos = HPos * float2(2.0, -2.0) + float2(-1.0, 1.0); // flip y axis

        float3 Bary;
        Barycentric(HPos, Vert[0], Vert[1], Vert[2], Bary);

        float2 UV = Texcoord[0] * Bary[0] + Texcoord[1] * Bary[1] + Texcoord[2] * Bary[2];

        PSOut.Color = g_Texture.SampleLevel(g_Texture_sampler, UV, 0);
    }
}
